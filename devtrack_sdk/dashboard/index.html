<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>DevTrack – API Live Dashboard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Chart.js CDN -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

  <style>
    :root {
      --bg: #0b1020;
      --card-bg: #151a2b;
      --accent: #4f46e5;
      --accent-soft: rgba(79, 70, 229, 0.1);
      --text: #f9fafb;
      --muted: #9ca3af;
      --danger: #f97373;
      --success: #4ade80;
      --border: #1f2937;
      --font: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: var(--font);
      background: radial-gradient(circle at top, #111827 0, #020617 60%);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      align-items: stretch;
      justify-content: center;
      padding: 24px;
    }

    .container {
      width: 100%;
      max-width: 1200px;
      margin: 0 auto;
    }

    .card {
      background: linear-gradient(135deg, rgba(15,23,42,0.92), rgba(15,23,42,0.98));
      border-radius: 18px;
      border: 1px solid #1f2937;
      padding: 20px 24px 22px 24px;
      box-shadow: 0 18px 45px rgba(0,0,0,0.45);
      backdrop-filter: blur(18px);
    }

    .header {
      display: flex;
      justify-content: space-between;
      gap: 12px;
      align-items: center;
      margin-bottom: 16px;
    }

    .title {
      font-size: 1.1rem;
      letter-spacing: 0.07em;
      text-transform: uppercase;
      color: var(--muted);
      margin-bottom: 4px;
    }

    .heading-row {
      display: flex;
      align-items: baseline;
      gap: 8px;
    }

    .heading-row h1 {
      margin: 0;
      font-size: 1.7rem;
    }

    .pill {
      font-size: 0.75rem;
      padding: 2px 8px;
      border-radius: 999px;
      background: var(--accent-soft);
      color: var(--accent);
      border: 1px solid rgba(79,70,229,0.4);
    }

    .subtext {
      margin: 0;
      font-size: 0.85rem;
      color: var(--muted);
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      justify-content: flex-end;
    }

    button {
      border: 1px solid rgba(148,163,184,0.5);
      background: rgba(15,23,42,0.9);
      color: var(--text);
      border-radius: 999px;
      padding: 6px 14px;
      font-size: 0.85rem;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition: all 0.15s ease;
    }

    button.primary {
      border-color: var(--accent);
      background: var(--accent);
      color: #e5e7eb;
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 25px rgba(0,0,0,0.35);
    }

    button:disabled {
      opacity: 0.6;
      cursor: default;
      transform: none;
      box-shadow: none;
    }

    select {
      background: rgba(15,23,42,0.9);
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.7);
      color: var(--text);
      padding: 6px 26px 6px 10px;
      font-size: 0.8rem;
      outline: none;
    }

    .status-bar {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      gap: 8px;
      align-items: center;
      margin-bottom: 14px;
      padding: 10px 12px;
      background: radial-gradient(circle at left, rgba(79,70,229,0.15), transparent 60%);
      border-radius: 14px;
      border: 1px solid rgba(55,65,81,0.8);
    }

    .status-left {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.8rem;
      color: var(--muted);
    }

    .dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: var(--success);
      box-shadow: 0 0 10px rgba(74,222,128,0.8);
    }

    .dot.off {
      background: var(--danger);
      box-shadow: 0 0 10px rgba(248,113,113,0.8);
    }

    .status-right {
      font-size: 0.8rem;
      color: var(--muted);
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .mono {
      font-family: "JetBrains Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.78rem;
    }

    .endpoint {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 260px;
    }

    .error {
      margin-top: 8px;
      padding: 8px 10px;
      border-radius: 10px;
      background: rgba(127,29,29,0.2);
      border: 1px solid rgba(248,113,113,0.5);
      color: #fecaca;
      font-size: 0.8rem;
    }

    .kpi-grid {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 10px;
      margin-top: 6px;
      margin-bottom: 12px;
    }

    .kpi-card {
      border-radius: 14px;
      padding: 10px 12px;
      background: radial-gradient(circle at top left, rgba(56,189,248,0.12), transparent 70%);
      border: 1px solid rgba(31,41,55,0.9);
      display: flex;
      flex-direction: column;
      gap: 4px;
      min-height: 68px;
    }

    .kpi-label {
      font-size: 0.75rem;
      color: var(--muted);
    }

    .kpi-value {
      font-size: 1.1rem;
      font-weight: 500;
    }

    .kpi-sub {
      font-size: 0.7rem;
      color: var(--muted);
    }

    .kpi-accent {
      color: var(--accent);
    }

    .kpi-danger {
      color: var(--danger);
    }

    .chart-wrapper {
      margin-top: 4px;
      margin-bottom: 8px;
      border-radius: 14px;
      border: 1px solid var(--border);
      background: radial-gradient(circle at top left, rgba(15,118,110,0.08), transparent 60%);
      padding: 10px 12px 12px 12px;
    }

    .chart-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 4px;
    }

    .chart-header h2 {
      margin: 0;
      font-size: 0.95rem;
      color: #e5e7eb;
    }

    .chart-sub {
      font-size: 0.72rem;
      color: var(--muted);
    }

    .chart-empty {
      font-size: 0.8rem;
      color: var(--muted);
      text-align: center;
      padding: 12px 0 8px 0;
    }

    .data-card {
      margin-top: 6px;
      border-radius: 14px;
      border: 1px solid var(--border);
      background: radial-gradient(circle at top left, rgba(15,118,110,0.08), transparent 60%);
      padding: 10px 10px 14px 10px;
    }

    .data-card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 6px;
    }

    .data-card-header h2 {
      margin: 0;
      font-size: 0.95rem;
      color: #e5e7eb;
    }

    .badge {
      border-radius: 999px;
      padding: 2px 8px;
      font-size: 0.72rem;
      border: 1px solid rgba(148,163,184,0.8);
      color: var(--muted);
    }

    .loader {
      font-size: 0.85rem;
      color: var(--muted);
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .spinner {
      width: 12px;
      height: 12px;
      border-radius: 999px;
      border: 2px solid rgba(148,163,184,0.5);
      border-top-color: var(--accent);
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 6px;
      font-size: 0.8rem;
    }

    thead {
      background: rgba(15,23,42,0.9);
    }

    th, td {
      border-bottom: 1px solid rgba(31,41,55,0.9);
      padding: 6px 6px;
      text-align: left;
    }

    th {
      font-weight: 500;
      color: var(--muted);
      font-size: 0.78rem;
    }

    tbody tr:hover {
      background: rgba(31,41,55,0.8);
    }

    .empty-state {
      padding: 14px 8px;
      font-size: 0.82rem;
      color: var(--muted);
      text-align: center;
    }

    pre.json-dump {
      margin: 0;
      padding: 10px;
      border-radius: 10px;
      background: rgba(15,23,42,0.95);
      border: 1px solid rgba(31,41,55,0.95);
      font-size: 0.78rem;
      overflow: auto;
      max-height: 260px;
    }

    @media (max-width: 900px) {
      .kpi-grid {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }

    @media (max-width: 720px) {
      .header {
        flex-direction: column;
        align-items: flex-start;
      }
      .controls {
        justify-content: flex-start;
      }
      .status-bar {
        flex-direction: column;
        align-items: flex-start;
      }
      .endpoint {
        max-width: 180px;
      }
      .kpi-grid {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }

    @media (max-width: 480px) {
      .kpi-grid {
        grid-template-columns: repeat(1, minmax(0, 1fr));
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="card">
      <div class="header">
        <div>
          <div class="title">DevTrack • Live Metrics</div>
          <div class="heading-row">
            <h1>API Health Dashboard</h1>
            <span class="pill">Auto-refresh</span>
          </div>
          <p class="subtext">
            Consumes DevTrack JSON stats and visualizes traffic, latency, and errors in real time.<br />
            Point this to your <span class="mono">/__devtrack__/stats</span> endpoint.
          </p>
        </div>

        <div class="controls">
          <select id="refresh-interval">
            <option value="5000">5s</option>
            <option value="10000" selected>10s</option>
            <option value="30000">30s</option>
            <option value="60000">60s</option>
            <option value="0">Pause</option>
          </select>
          <button id="refresh-btn" class="primary">
            ⟳ Refresh now
          </button>
        </div>
      </div>

      <div class="status-bar">
        <div class="status-left">
          <span id="status-dot" class="dot"></span>
          <span id="status-text">Idle</span>
        </div>
        <div class="status-right">
          <span>Endpoint:</span>
          <span class="mono endpoint" id="endpoint-label"></span>
          <span>| Last updated: <span id="last-updated">–</span></span>
        </div>
      </div>

      <div id="error-box" class="error" style="display: none;"></div>

      <!-- KPI Cards (based on your summary) -->
      <div class="kpi-grid">
        <div class="kpi-card">
          <div class="kpi-label">Total Requests</div>
          <div class="kpi-value mono" id="kpi-total-req">–</div>
          <div class="kpi-sub" id="kpi-success-error">Success: –, Error: –</div>
        </div>
        <div class="kpi-card">
          <div class="kpi-label">Unique Endpoints</div>
          <div class="kpi-value mono" id="kpi-unique-endpoints">–</div>
          <div class="kpi-sub">Observed in this sample</div>
        </div>
        <div class="kpi-card">
          <div class="kpi-label">Average Latency</div>
          <div class="kpi-value mono kpi-accent" id="kpi-avg-lat">–</div>
          <div class="kpi-sub">From DevTrack summary</div>
        </div>
        <div class="kpi-card">
          <div class="kpi-label">Error Rate</div>
          <div class="kpi-value mono kpi-danger" id="kpi-error-rate">–</div>
          <div class="kpi-sub">error_count / total_requests</div>
        </div>
      </div>

      <!-- Traffic Overview -->
      <div class="chart-wrapper">
        <div class="chart-header">
          <h2>Traffic Overview</h2>
          <span class="chart-sub">Requests over time</span>
        </div>
        <div id="traffic-chart-container">
          <canvas id="trafficChart" height="120"></canvas>
        </div>
        <div id="traffic-chart-empty" class="chart-empty" style="display:none;">
          No traffic data available. Trigger some requests to see the chart.
        </div>
      </div>

      <!-- Error Trends -->
      <div class="chart-wrapper">
        <div class="chart-header">
          <h2>Error Trends</h2>
          <span class="chart-sub">Failure rates over time</span>
        </div>
        <div id="error-trends-chart-container">
          <canvas id="errorTrendsChart" height="120"></canvas>
        </div>
        <div id="error-trends-chart-empty" class="chart-empty" style="display:none;">
          No error data available.
        </div>
      </div>

      <div class="data-card" style="margin-top: 6px;">
        <div class="data-card-header">
          <h2>Top Failing Routes</h2>
          <span class="badge" id="top-failing-count-badge">0 routes</span>
        </div>
        <div id="top-failing-routes-container"></div>
      </div>

      <!-- Performance Metrics -->
      <div class="chart-wrapper" style="margin-top: 6px;">
        <div class="chart-header">
          <h2>Performance Metrics</h2>
          <span class="chart-sub">p50/p95/p99 latency over time</span>
        </div>
        <div id="perf-chart-container">
          <canvas id="perfChart" height="120"></canvas>
        </div>
        <div id="perf-chart-empty" class="chart-empty" style="display:none;">
          No performance data available.
        </div>
        <div id="perf-overall" style="margin-top: 8px; display: flex; gap: 12px; flex-wrap: wrap; font-size: 0.75rem; color: var(--muted);">
          <span>Overall p50: <span class="mono kpi-accent" id="perf-overall-p50">–</span></span>
          <span>Overall p95: <span class="mono kpi-accent" id="perf-overall-p95">–</span></span>
          <span>Overall p99: <span class="mono kpi-accent" id="perf-overall-p99">–</span></span>
          <span>Overall avg: <span class="mono kpi-accent" id="perf-overall-avg">–</span></span>
        </div>
      </div>

      <!-- Chart Area (Original) -->
      <div class="chart-wrapper">
        <div class="chart-header">
          <h2>Latency & Errors (Last Requests)</h2>
          <span class="chart-sub">Per-request latency vs error flag</span>
        </div>
        <div id="chart-container">
          <canvas id="latencyChart" height="120"></canvas>
        </div>
        <div id="chart-empty" class="chart-empty" style="display:none;">
          No <span class="mono">entries[]</span> found in response.  
          Trigger some traffic to see the chart.
        </div>
      </div>

      <!-- Consumer Segmentation -->
      <div class="data-card" style="margin-top: 6px;">
        <div class="data-card-header">
          <h2>Consumer Segmentation</h2>
          <span class="badge" id="consumers-count-badge">0 clients</span>
        </div>
        <div id="consumers-container"></div>
      </div>

      <div class="data-card">
        <div class="data-card-header">
          <h2>Request Logs</h2>
          <span class="badge" id="record-count-badge">0 records</span>
        </div>

        <div style="margin-bottom: 10px; display: flex; gap: 8px; flex-wrap: wrap; align-items: center;">
          <input 
            type="text" 
            id="search-input" 
            placeholder="Search logs..." 
            style="flex: 1; min-width: 200px; padding: 6px 10px; border-radius: 8px; border: 1px solid rgba(148,163,184,0.5); background: rgba(15,23,42,0.9); color: var(--text); font-size: 0.85rem; outline: none;"
          />
          <select id="filter-method" style="padding: 6px 10px; border-radius: 8px; border: 1px solid rgba(148,163,184,0.5); background: rgba(15,23,42,0.9); color: var(--text); font-size: 0.85rem; outline: none;">
            <option value="">All Methods</option>
            <option value="GET">GET</option>
            <option value="POST">POST</option>
            <option value="PUT">PUT</option>
            <option value="DELETE">DELETE</option>
            <option value="PATCH">PATCH</option>
          </select>
          <select id="filter-status" style="padding: 6px 10px; border-radius: 8px; border: 1px solid rgba(148,163,184,0.5); background: rgba(15,23,42,0.9); color: var(--text); font-size: 0.85rem; outline: none;">
            <option value="">All Status</option>
            <option value="2xx">2xx Success</option>
            <option value="4xx">4xx Client Error</option>
            <option value="5xx">5xx Server Error</option>
          </select>
          <button id="clear-filters" style="padding: 6px 12px; font-size: 0.85rem;">
            Clear Filters
          </button>
        </div>

        <div id="loader" class="loader" style="display: none;">
          <span class="spinner"></span>
          <span>Fetching latest data…</span>
        </div>

        <div id="table-container"></div>
      </div>
    </div>
  </div>

  <script>
    // === CONFIG ==========================================
    const API_URL = "http://localhost:8000/__devtrack__/stats"; // ← adjust to your endpoint
    const TRAFFIC_API_URL = "http://localhost:8000/__devtrack__/metrics/traffic";
    const ERRORS_API_URL = "http://localhost:8000/__devtrack__/metrics/errors";
    const PERF_API_URL = "http://localhost:8000/__devtrack__/metrics/perf";
    const CONSUMERS_API_URL = "http://localhost:8000/__devtrack__/consumers";
    const MAX_RECORDS_LIMIT = 100000; // High limit to get all records
    let refreshIntervalMs = 5000; // default 5s
    let refreshTimer = null;
    let latencyChart = null;
    let trafficChart = null;
    let errorTrendsChart = null;
    let perfChart = null;
    let allEntries = []; // Store all entries for filtering

    // === DOM REFS ========================================
    const endpointLabelEl = document.getElementById("endpoint-label");
    const lastUpdatedEl = document.getElementById("last-updated");
    const errorBoxEl = document.getElementById("error-box");
    const tableContainerEl = document.getElementById("table-container");
    const statusDotEl = document.getElementById("status-dot");
    const statusTextEl = document.getElementById("status-text");
    const loaderEl = document.getElementById("loader");
    const recordCountBadgeEl = document.getElementById("record-count-badge");
    const refreshBtn = document.getElementById("refresh-btn");
    const refreshIntervalSelect = document.getElementById("refresh-interval");

    const kpiTotalReqEl = document.getElementById("kpi-total-req");
    const kpiUniqueEndpointsEl = document.getElementById("kpi-unique-endpoints");
    const kpiAvgLatEl = document.getElementById("kpi-avg-lat");
    const kpiErrorRateEl = document.getElementById("kpi-error-rate");
    const kpiSuccessErrorEl = document.getElementById("kpi-success-error");

    const chartCanvas = document.getElementById("latencyChart");
    const chartContainer = document.getElementById("chart-container");
    const chartEmptyEl = document.getElementById("chart-empty");

    const trafficChartCanvas = document.getElementById("trafficChart");
    const trafficChartContainer = document.getElementById("traffic-chart-container");
    const trafficChartEmptyEl = document.getElementById("traffic-chart-empty");

    const errorTrendsChartCanvas = document.getElementById("errorTrendsChart");
    const errorTrendsChartContainer = document.getElementById("error-trends-chart-container");
    const errorTrendsChartEmptyEl = document.getElementById("error-trends-chart-empty");

    const perfChartCanvas = document.getElementById("perfChart");
    const perfChartContainer = document.getElementById("perf-chart-container");
    const perfChartEmptyEl = document.getElementById("perf-chart-empty");

    const topFailingRoutesContainer = document.getElementById("top-failing-routes-container");
    const topFailingCountBadge = document.getElementById("top-failing-count-badge");
    const searchInput = document.getElementById("search-input");
    const filterMethod = document.getElementById("filter-method");
    const filterStatus = document.getElementById("filter-status");
    const clearFiltersBtn = document.getElementById("clear-filters");
    const consumersContainer = document.getElementById("consumers-container");
    const consumersCountBadge = document.getElementById("consumers-count-badge");

    endpointLabelEl.textContent = API_URL;

    // === HELPERS =========================================
    function setStatus(isOnline, message) {
      statusDotEl.classList.toggle("off", !isOnline);
      statusTextEl.textContent = message;
    }

    function setLoading(isLoading) {
      loaderEl.style.display = isLoading ? "inline-flex" : "none";
      refreshBtn.disabled = isLoading;
    }

    function showError(message) {
      if (!message) {
        errorBoxEl.style.display = "none";
        errorBoxEl.textContent = "";
        return;
      }
      errorBoxEl.style.display = "block";
      errorBoxEl.textContent = message;
    }

    function formatTime(date) {
      return date.toLocaleTimeString(undefined, {
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit"
      });
    }

    function isPlainObject(value) {
      return value && typeof value === "object" && !Array.isArray(value);
    }

    function formatNumber(n) {
      if (n === null || n === undefined || isNaN(n)) return "–";
      return Number(n).toLocaleString();
    }

    function formatMs(n) {
      if (n === null || n === undefined || isNaN(n)) return "–";
      return `${Number(n).toFixed(2)} ms`;
    }

    function formatPercent(n) {
      if (n === null || n === undefined || isNaN(n)) return "–";
      return `${Number(n).toFixed(2)}%`;
    }

    // === DEVTRACK LAYOUT RENDERING =======================

    function renderKpis(data) {
      const summary = (data && data.summary && isPlainObject(data.summary))
        ? data.summary
        : {};

      const totalRequests = summary.total_requests ?? data.total;
      const uniqueEndpoints = summary.unique_endpoints;
      const avgDuration = summary.avg_duration_ms;
      const successCount = summary.success_count;
      const errorCount = summary.error_count;

      let errorRate = null;
      if (typeof totalRequests === "number" && totalRequests > 0 && typeof errorCount === "number") {
        errorRate = (errorCount / totalRequests) * 100;
      }

      kpiTotalReqEl.textContent = totalRequests !== undefined ? formatNumber(totalRequests) : "–";
      kpiUniqueEndpointsEl.textContent = uniqueEndpoints !== undefined ? formatNumber(uniqueEndpoints) : "–";
      kpiAvgLatEl.textContent = avgDuration !== undefined ? formatMs(avgDuration) : "–";
      kpiErrorRateEl.textContent = errorRate !== null ? formatPercent(errorRate) : "–";

      const successText = (typeof successCount === "number") ? successCount : "–";
      const errorText = (typeof errorCount === "number") ? errorCount : "–";
      kpiSuccessErrorEl.textContent = `Success: ${successText}, Error: ${errorText}`;
    }

    function extractEntries(data) {
      if (data && Array.isArray(data.entries)) return data.entries;
      return [];
    }

    function renderChart(data) {
      const entries = extractEntries(data);

      if (!entries.length) {
        chartContainer.style.display = "none";
        chartEmptyEl.style.display = "block";
        return;
      }

      chartContainer.style.display = "block";
      chartEmptyEl.style.display = "none";

      const labels = [];
      const latencyData = [];
      const errorFlagData = [];

      for (const entry of entries) {
        const ts = entry.timestamp ?? entry.created_at ?? null;
        const latency = entry.duration_ms ?? null;
        const statusCode = entry.status_code ?? null;

        // Label from timestamp
        let label;
        if (ts) {
          const d = new Date(ts);
          if (!isNaN(d.getTime())) {
            label = d.toLocaleTimeString(undefined, {
              hour: "2-digit",
              minute: "2-digit",
              second: "2-digit"
            });
          } else {
            label = String(ts);
          }
        } else {
          label = `${labels.length + 1}`;
        }

        labels.push(label);
        latencyData.push(latency ?? null);

        // 0 if < 400, 100 if >= 400
        if (typeof statusCode === "number" && statusCode >= 400) {
          errorFlagData.push(100);
        } else {
          errorFlagData.push(0);
        }
      }

      const chartData = {
        labels,
        datasets: [
          {
            label: "Latency (ms)",
            data: latencyData,
            yAxisID: "y",
            tension: 0.3,
            borderWidth: 2,
            pointRadius: 2
          },
          {
            label: "Error flag (0 / 100%)",
            data: errorFlagData,
            yAxisID: "y1",
            tension: 0.3,
            borderDash: [4, 4],
            borderWidth: 2,
            pointRadius: 2
          }
        ]
      };

      const chartConfig = {
        type: "line",
        data: chartData,
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: {
            mode: "index",
            intersect: false
          },
          plugins: {
            legend: {
              labels: {
                color: "#e5e7eb",
                font: { size: 11 }
              }
            },
            tooltip: {
              callbacks: {
                label: function(ctx) {
                  const label = ctx.dataset.label || "";
                  const value = ctx.parsed.y;
                  if (label.toLowerCase().includes("latency")) {
                    return `${label}: ${value.toFixed(2)} ms`;
                  } else {
                    return `${label}: ${value.toFixed(0)}%`;
                  }
                }
              }
            }
          },
          scales: {
            x: {
              ticks: {
                color: "#9ca3af",
                maxRotation: 45,
                minRotation: 0,
                autoSkip: true,
                maxTicksLimit: 8,
                font: { size: 10 }
              },
              grid: {
                color: "rgba(55,65,81,0.4)"
              }
            },
            y: {
              position: "left",
              title: {
                display: true,
                text: "Latency (ms)",
                color: "#9ca3af"
              },
              ticks: {
                color: "#9ca3af",
                font: { size: 10 }
              },
              grid: {
                color: "rgba(31,41,55,0.5)"
              }
            },
            y1: {
              position: "right",
              title: {
                display: true,
                text: "Error flag (%)",
                color: "#9ca3af"
              },
              ticks: {
                color: "#9ca3af",
                font: { size: 10 }
              },
              grid: {
                drawOnChartArea: false
              },
              min: 0,
              max: 100
            }
          }
        }
      };

      if (latencyChart) {
        latencyChart.data = chartData;
        latencyChart.options = chartConfig.options;
        latencyChart.update();
      } else {
        latencyChart = new Chart(chartCanvas, chartConfig);
      }
    }

    // === TABLE / RAW RENDERING ===========================

    function renderTableFromArray(arr) {
      if (!arr.length) {
        tableContainerEl.innerHTML = '<div class="empty-state">No records returned from API.</div>';
        recordCountBadgeEl.textContent = "0 records";
        return;
      }

      const keys = Array.from(
        arr.reduce((set, obj) => {
          if (isPlainObject(obj)) {
            Object.keys(obj).forEach(k => set.add(k));
          }
          return set;
        }, new Set())
      );

      const headerHtml = keys.map(k => `<th>${k}</th>`).join("");
      const bodyHtml = arr.map(row => {
        const cells = keys.map(k => {
          let val = row[k];
          if (val === null || val === undefined) return "<td>–</td>";
          if (typeof val === "object") {
            return `<td><span class="mono">${JSON.stringify(val)}</span></td>`;
          }
          return `<td>${val}</td>`;
        }).join("");
        return `<tr>${cells}</tr>`;
      }).join("");

      tableContainerEl.innerHTML = `
        <div style="overflow: auto; max-height: 320px;">
          <table>
            <thead><tr>${headerHtml}</tr></thead>
            <tbody>${bodyHtml}</tbody>
          </table>
        </div>
      `;

      recordCountBadgeEl.textContent = `${arr.length} record${arr.length !== 1 ? "s" : ""}`;
    }

    function renderFallbackJson(data) {
      tableContainerEl.innerHTML = `
        <div class="empty-state" style="text-align:left;">
          Response does not have <span class="mono">entries[]</span>; showing raw JSON.
        </div>
        <pre class="json-dump">${JSON.stringify(data, null, 2)}</pre>
      `;
      recordCountBadgeEl.textContent = "–";
    }

    function renderData(data) {
      // DevTrack-specific bits
      renderKpis(data);
      renderChart(data);

      const entries = extractEntries(data);
      allEntries = entries; // Store for filtering
      
      // Re-apply filters after data update (preserves filter state)
      if (entries.length) {
        filterAndRenderTable();
      } else {
        renderFallbackJson(data);
      }
    }

    // === TRAFFIC OVERVIEW =================================
    async function fetchAndRenderTraffic() {
      try {
        const timestamp = new Date().getTime();
        const res = await fetch(`${TRAFFIC_API_URL}?hours=24&_t=${timestamp}`, {
          headers: { 
            "Accept": "application/json",
            "Cache-Control": "no-cache, no-store, must-revalidate"
          },
          cache: "no-store"
        });
        if (!res.ok) return;
        const data = await res.json();
        renderTrafficChart(data.traffic || []);
      } catch (err) {
        console.error("Failed to fetch traffic data:", err);
      }
    }

    function renderTrafficChart(trafficData) {
      if (!trafficData.length) {
        trafficChartContainer.style.display = "none";
        trafficChartEmptyEl.style.display = "block";
        return;
      }

      trafficChartContainer.style.display = "block";
      trafficChartEmptyEl.style.display = "none";

      const labels = trafficData.map(d => {
        const date = new Date(d.timestamp);
        return date.toLocaleTimeString(undefined, { hour: "2-digit", minute: "2-digit" });
      });
      const counts = trafficData.map(d => d.count);

      const chartData = {
        labels,
        datasets: [{
          label: "Requests",
          data: counts,
          borderColor: "#4f46e5",
          backgroundColor: "rgba(79, 70, 229, 0.1)",
          tension: 0.3,
          fill: true,
          borderWidth: 2,
          pointRadius: 2
        }]
      };

      const config = {
        type: "line",
        data: chartData,
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { labels: { color: "#e5e7eb", font: { size: 11 } } }
          },
          scales: {
            x: { ticks: { color: "#9ca3af", maxTicksLimit: 10 }, grid: { color: "rgba(55,65,81,0.4)" } },
            y: { ticks: { color: "#9ca3af" }, grid: { color: "rgba(31,41,55,0.5)" }, title: { display: true, text: "Requests", color: "#9ca3af" } }
          }
        }
      };

      if (trafficChart) {
        trafficChart.data = chartData;
        trafficChart.update();
      } else {
        trafficChart = new Chart(trafficChartCanvas, config);
      }
    }

    // === ERROR TRENDS =====================================
    async function fetchAndRenderErrors() {
      try {
        const timestamp = new Date().getTime();
        const res = await fetch(`${ERRORS_API_URL}?hours=24&_t=${timestamp}`, {
          headers: { 
            "Accept": "application/json",
            "Cache-Control": "no-cache, no-store, must-revalidate"
          },
          cache: "no-store"
        });
        if (!res.ok) return;
        const data = await res.json();
        renderErrorTrendsChart(data.trends || []);
        renderTopFailingRoutes(data.top_failing_routes || []);
      } catch (err) {
        console.error("Failed to fetch error data:", err);
      }
    }

    function renderErrorTrendsChart(trendsData) {
      if (!trendsData.length) {
        errorTrendsChartContainer.style.display = "none";
        errorTrendsChartEmptyEl.style.display = "block";
        return;
      }

      errorTrendsChartContainer.style.display = "block";
      errorTrendsChartEmptyEl.style.display = "none";

      const labels = trendsData.map(d => {
        const date = new Date(d.timestamp);
        return date.toLocaleTimeString(undefined, { hour: "2-digit", minute: "2-digit" });
      });
      const errorRates = trendsData.map(d => d.error_rate || 0);

      const chartData = {
        labels,
        datasets: [{
          label: "Error Rate (%)",
          data: errorRates,
          borderColor: "#f97373",
          backgroundColor: "rgba(249, 115, 115, 0.1)",
          tension: 0.3,
          fill: true,
          borderWidth: 2,
          pointRadius: 2
        }]
      };

      const config = {
        type: "line",
        data: chartData,
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { labels: { color: "#e5e7eb", font: { size: 11 } } }
          },
          scales: {
            x: { ticks: { color: "#9ca3af", maxTicksLimit: 10 }, grid: { color: "rgba(55,65,81,0.4)" } },
            y: { ticks: { color: "#9ca3af" }, grid: { color: "rgba(31,41,55,0.5)" }, title: { display: true, text: "Error Rate (%)", color: "#9ca3af" }, min: 0, max: 100 }
          }
        }
      };

      if (errorTrendsChart) {
        errorTrendsChart.data = chartData;
        errorTrendsChart.update();
      } else {
        errorTrendsChart = new Chart(errorTrendsChartCanvas, config);
      }
    }

    function renderTopFailingRoutes(routes) {
      if (!routes.length) {
        topFailingRoutesContainer.innerHTML = '<div class="empty-state">No failing routes found.</div>';
        topFailingCountBadge.textContent = "0 routes";
        return;
      }

      const tableHtml = `
        <div style="overflow: auto; max-height: 200px;">
          <table>
            <thead>
              <tr>
                <th>Path</th>
                <th>Method</th>
                <th>Error Count</th>
                <th>Error %</th>
              </tr>
            </thead>
            <tbody>
              ${routes.map(route => `
                <tr>
                  <td class="mono">${route.path || "–"}</td>
                  <td><span class="badge">${route.method || "–"}</span></td>
                  <td>${formatNumber(route.error_count)}</td>
                  <td class="kpi-danger">${formatPercent(route.error_percentage)}</td>
                </tr>
              `).join("")}
            </tbody>
          </table>
        </div>
      `;
      topFailingRoutesContainer.innerHTML = tableHtml;
      topFailingCountBadge.textContent = `${routes.length} route${routes.length !== 1 ? "s" : ""}`;
    }

    // === PERFORMANCE METRICS =============================
    async function fetchAndRenderPerf() {
      try {
        const timestamp = new Date().getTime();
        const res = await fetch(`${PERF_API_URL}?hours=24&_t=${timestamp}`, {
          headers: { 
            "Accept": "application/json",
            "Cache-Control": "no-cache, no-store, must-revalidate"
          },
          cache: "no-store"
        });
        if (!res.ok) return;
        const data = await res.json();
        renderPerfChart(data.over_time || []);
        renderPerfOverall(data.overall || {});
      } catch (err) {
        console.error("Failed to fetch performance data:", err);
      }
    }

    function renderPerfChart(perfData) {
      if (!perfData.length) {
        perfChartContainer.style.display = "none";
        perfChartEmptyEl.style.display = "block";
        return;
      }

      perfChartContainer.style.display = "block";
      perfChartEmptyEl.style.display = "none";

      const labels = perfData.map(d => {
        const date = new Date(d.timestamp);
        return date.toLocaleTimeString(undefined, { hour: "2-digit", minute: "2-digit" });
      });
      const p50Data = perfData.map(d => d.p50);
      const p95Data = perfData.map(d => d.p95);
      const p99Data = perfData.map(d => d.p99);

      const chartData = {
        labels,
        datasets: [
          {
            label: "p50",
            data: p50Data,
            borderColor: "#4ade80",
            backgroundColor: "rgba(74, 222, 128, 0.1)",
            tension: 0.3,
            borderWidth: 2,
            pointRadius: 1
          },
          {
            label: "p95",
            data: p95Data,
            borderColor: "#fbbf24",
            backgroundColor: "rgba(251, 191, 36, 0.1)",
            tension: 0.3,
            borderWidth: 2,
            pointRadius: 1
          },
          {
            label: "p99",
            data: p99Data,
            borderColor: "#f97373",
            backgroundColor: "rgba(249, 115, 115, 0.1)",
            tension: 0.3,
            borderWidth: 2,
            pointRadius: 1
          }
        ]
      };

      const config = {
        type: "line",
        data: chartData,
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { labels: { color: "#e5e7eb", font: { size: 11 } } }
          },
          scales: {
            x: { ticks: { color: "#9ca3af", maxTicksLimit: 10 }, grid: { color: "rgba(55,65,81,0.4)" } },
            y: { ticks: { color: "#9ca3af" }, grid: { color: "rgba(31,41,55,0.5)" }, title: { display: true, text: "Latency (ms)", color: "#9ca3af" } }
          }
        }
      };

      if (perfChart) {
        perfChart.data = chartData;
        perfChart.update();
      } else {
        perfChart = new Chart(perfChartCanvas, config);
      }
    }

    function renderPerfOverall(overall) {
      document.getElementById("perf-overall-p50").textContent = overall.p50 !== null && overall.p50 !== undefined ? formatMs(overall.p50) : "–";
      document.getElementById("perf-overall-p95").textContent = overall.p95 !== null && overall.p95 !== undefined ? formatMs(overall.p95) : "–";
      document.getElementById("perf-overall-p99").textContent = overall.p99 !== null && overall.p99 !== undefined ? formatMs(overall.p99) : "–";
      document.getElementById("perf-overall-avg").textContent = overall.avg !== null && overall.avg !== undefined ? formatMs(overall.avg) : "–";
    }

    // === SEARCH & FILTER ==================================
    function saveFilterState() {
      // Save filter state to localStorage for persistence across page refreshes
      const filterState = {
        search: searchInput.value,
        method: filterMethod.value,
        status: filterStatus.value
      };
      localStorage.setItem("devtrack_filters", JSON.stringify(filterState));
    }

    function loadFilterState() {
      // Load filter state from localStorage
      try {
        const saved = localStorage.getItem("devtrack_filters");
        if (saved) {
          const filterState = JSON.parse(saved);
          searchInput.value = filterState.search || "";
          filterMethod.value = filterState.method || "";
          filterStatus.value = filterState.status || "";
        }
      } catch (e) {
        // Ignore errors (e.g., localStorage disabled)
      }
    }

    function filterAndRenderTable() {
      const searchTerm = searchInput.value.toLowerCase();
      const methodFilter = filterMethod.value;
      const statusFilter = filterStatus.value;

      // Save filter state
      saveFilterState();

      // If no entries, show empty state
      if (!allEntries.length) {
        tableContainerEl.innerHTML = '<div class="empty-state">No records available.</div>';
        recordCountBadgeEl.textContent = "0 records";
        return;
      }

      let filtered = allEntries.filter(entry => {
        // Search filter
        if (searchTerm) {
          const searchableText = JSON.stringify(entry).toLowerCase();
          if (!searchableText.includes(searchTerm)) return false;
        }

        // Method filter
        if (methodFilter && entry.method !== methodFilter) return false;

        // Status filter
        if (statusFilter) {
          const status = entry.status_code;
          if (statusFilter === "2xx" && (status < 200 || status >= 300)) return false;
          if (statusFilter === "4xx" && (status < 400 || status >= 500)) return false;
          if (statusFilter === "5xx" && status < 500) return false;
        }

        return true;
      });

      renderTableFromArray(filtered);
    }

    searchInput.addEventListener("input", filterAndRenderTable);
    filterMethod.addEventListener("change", filterAndRenderTable);
    filterStatus.addEventListener("change", filterAndRenderTable);
    clearFiltersBtn.addEventListener("click", () => {
      searchInput.value = "";
      filterMethod.value = "";
      filterStatus.value = "";
      saveFilterState(); // Clear saved state
      filterAndRenderTable();
    });

    // === CONSUMER SEGMENTATION ===========================
    async function fetchAndRenderConsumers() {
      try {
        const timestamp = new Date().getTime();
        const res = await fetch(`${CONSUMERS_API_URL}?hours=24&_t=${timestamp}`, {
          headers: { 
            "Accept": "application/json",
            "Cache-Control": "no-cache, no-store, must-revalidate"
          },
          cache: "no-store"
        });
        if (!res.ok) return;
        const data = await res.json();
        renderConsumers(data);
      } catch (err) {
        console.error("Failed to fetch consumer data:", err);
      }
    }

    function renderConsumers(data) {
      if (!data.segments || !data.segments.length) {
        consumersContainer.innerHTML = '<div class="empty-state">No consumer data available.</div>';
        consumersCountBadge.textContent = "0 clients";
        return;
      }

      const segments = data.segments;
      consumersCountBadge.textContent = `${data.total_unique_clients || segments.length} client${(data.total_unique_clients || segments.length) !== 1 ? "s" : ""}`;

      const tableHtml = `
        <div style="overflow: auto; max-height: 300px;">
          <table>
            <thead>
              <tr>
                <th>Client Hash</th>
                <th>Public IP</th>
                <th>Requests</th>
                <th>Endpoints</th>
                <th>Avg Latency</th>
                <th>Error Rate</th>
                <th>Last Seen</th>
              </tr>
            </thead>
            <tbody>
              ${segments.map(segment => `
                <tr>
                  <td class="mono" style="font-size: 0.7rem; color: var(--accent);">${segment.client_hash || "–"}</td>
                  <td class="mono" style="font-size: 0.75rem;">${segment.public_ip || "–"}</td>
                  <td>${formatNumber(segment.request_count)}</td>
                  <td>${formatNumber(segment.unique_endpoints)}</td>
                  <td>${segment.avg_latency !== null && segment.avg_latency !== undefined ? formatMs(segment.avg_latency) : "–"}</td>
                  <td class="${segment.error_rate > 10 ? "kpi-danger" : ""}">${formatPercent(segment.error_rate)}</td>
                  <td class="mono" style="font-size: 0.7rem;">${segment.last_seen ? new Date(segment.last_seen).toLocaleString() : "–"}</td>
                </tr>
              `).join("")}
            </tbody>
          </table>
        </div>
        ${data.source_breakdown ? `
          <div style="margin-top: 10px; padding: 8px; background: rgba(15,23,42,0.5); border-radius: 8px; font-size: 0.75rem; color: var(--muted);">
            <strong>Source Breakdown:</strong> 
            ${data.source_breakdown.identified ? `${data.source_breakdown.identified.client_count} identified clients` : "0 identified"} | 
            ${data.source_breakdown.unknown ? `${data.source_breakdown.unknown.client_count} unknown clients` : "0 unknown"}
          </div>
        ` : ""}
      `;
      consumersContainer.innerHTML = tableHtml;
    }

    // === FETCH LOGIC =====================================

    async function fetchData() {
      setLoading(true);
      showError("");
      setStatus(true, "Fetching…");

      try {
        // Fetch main stats - request all records with high limit
        // Add timestamp to prevent caching
        const timestamp = new Date().getTime();
        const res = await fetch(`${API_URL}?limit=${MAX_RECORDS_LIMIT}&_t=${timestamp}`, {
          headers: {
            "Accept": "application/json",
            "Cache-Control": "no-cache, no-store, must-revalidate",
            "Pragma": "no-cache"
          },
          cache: "no-store"
        });

        if (!res.ok) {
          throw new Error(`HTTP ${res.status} ${res.statusText}`);
        }

        const data = await res.json();
        
        // Debug logging
        const entryCount = data.entries?.length || 0;
        const totalCount = data.total || data.summary?.total_requests || 0;
        console.log(`[DevTrack] Fetched ${entryCount} entries, Total in DB: ${totalCount}`);
        
        // Check if data actually changed
        if (entryCount > 0) {
          const latestEntry = data.entries[0];
          console.log(`[DevTrack] Latest entry timestamp: ${latestEntry.timestamp}`);
        }
        
        renderData(data);

        // Fetch additional metrics
        await Promise.all([
          fetchAndRenderTraffic(),
          fetchAndRenderErrors(),
          fetchAndRenderPerf(),
          fetchAndRenderConsumers()
        ]);

        const now = new Date();
        lastUpdatedEl.textContent = formatTime(now);
        setStatus(true, "Online · Last fetch successful");
      } catch (err) {
        console.error(err);
        showError(`Failed to fetch data: ${err.message}`);
        setStatus(false, "Offline · Error while fetching");
      } finally {
        setLoading(false);
      }
    }

    function startAutoRefresh() {
      if (refreshTimer) {
        clearInterval(refreshTimer);
      }
      if (refreshIntervalMs > 0) {
        refreshTimer = setInterval(fetchData, refreshIntervalMs);
      } else {
        setStatus(true, "Paused · Auto-refresh off");
      }
    }

    // === EVENT HANDLERS ==================================
    refreshBtn.addEventListener("click", () => {
      fetchData();
    });

    refreshIntervalSelect.addEventListener("change", (e) => {
      const value = Number(e.target.value);
      refreshIntervalMs = value;
      if (value === 0) {
        if (refreshTimer) clearInterval(refreshTimer);
        setStatus(true, "Paused · Auto-refresh off");
      } else {
        startAutoRefresh();
        setStatus(true, `Online · Auto-refresh every ${value / 1000}s`);
      }
    });

    // === INIT ============================================
    (function init() {
      // Load saved filter state
      loadFilterState();
      
      setStatus(true, "Idle · Waiting for first fetch");
      fetchData();        // initial load
      startAutoRefresh(); // start timer
    })();
  </script>
</body>
</html>